// copied and modified from https://github.com/HuakunShen/tauri-demo/tree/master/examples/drizzle-sqlite-proxy/src/lib/db
import { drizzle, SqliteRemoteDatabase } from "drizzle-orm/sqlite-proxy";
import Database from "@tauri-apps/plugin-sql";
import { readTextFile } from '@tauri-apps/plugin-fs';
import { resolveResource } from "@tauri-apps/api/path";
import * as defaultSchema from "./schema";
/**
 * Creates a drizzle database instance of SQLite.
 * @param schema - The schema of the database.
 * @param name - The name of the database.
 * @param migrationFolder - The folder containing the migrations, generated by drizzle-kit.
 * @returns The drizzle database instance.
 */

export async function getSQLiteDB<TSchema extends Record<string, unknown> = Record<string, never>>
  (schema: TSchema = defaultSchema as unknown as TSchema,
    name: string = "app", migrationFolder: string = "migrations")
  : Promise<SqliteRemoteDatabase<TSchema>> {
  const sqlite = await migrate(await getLocalDB(name), migrationFolder);
  return drizzle<TSchema>(
    async (sql, params, method) => {
      let rows: any = [];
      let results = [];

      // If the query is a SELECT, use the select method
      if (isSelectQuery(sql)) {
        rows = await sqlite.select(sql, params).catch((e) => {
          console.error("SQL Error:", e);
          return [];
        });
      } else {
        // Otherwise, use the execute method
        rows = await sqlite.execute(sql, params).catch((e) => {
          console.error("SQL Error:", e);
          return [];
        });
        return { rows: [] };
      }

      rows = rows.map((row: any) => {
        return Object.values(row);
      });

      // If the method is "all", return all rows
      results = method === "all" ? rows : rows[0];
      await sqlite.close();
      return { rows: results };
    },
    // Pass the schema to the drizzle instance
    { schema: schema, logger: true }
  );
}

/**
 * Represents the result of a SELECT query.
 */
export type SelectQueryResult = {
  [key: string]: any;
};

/**
 * Loads the sqlite database via the Tauri Proxy.
 * @param name - The name of the database.
 * @returns The sqlite database.
 */

export async function getLocalDB(name?: string) {
  if (!name) {
    name = "test";
  }
  return await Database.load(`sqlite:${name}.db`);
}

/**
 * Checks if the given SQL query is a SELECT query.
 * @param sql The SQL query to check.
 * @returns True if the query is a SELECT query, false otherwise.
 */
function isSelectQuery(sql: string): boolean {
  const selectRegex = /^\s*SELECT\b/i;
  return selectRegex.test(sql);
}

/**
 * Executes database migrations.
 *
 * @param sqlite The database instance.
 * @param migrationFolder relative path (in $RESOURCE) to the folder, containing the migration files generated by drizzle-kit. 
 * @returns A promise that resolves when the migrations are complete.
 */
export async function migrate(sqlite: Database, migrationFolder: string): Promise<Database> {
  const migrationTableCreate = /*sql*/ `
		CREATE TABLE IF NOT EXISTS "__drizzle_migrations" (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            idx INTEGER NOT NULL UNIQUE,
            tag text NOT NULL UNIQUE,
			      created_at numeric
		)
	`;
  await sqlite.execute(migrationTableCreate, []);

  // const migrationDir = await join(await resourceDir(), migrationFolder);
  const migrationIndex = await readTextFile(await resolveResource(`${migrationFolder}/meta/_journal.json`));
  const migrationIndexJson = JSON.parse(migrationIndex);
  const migrationEntries = migrationIndexJson.entries as { idx: number; version: string; when: number; tag: string; breakpoints: boolean }[];

  for (const entry of migrationEntries) {
    const dbMigrations = (await sqlite.select(
      /*sql*/ `SELECT id, idx, tag, created_at FROM "__drizzle_migrations" ORDER BY created_at DESC`
    )) as unknown as { id: number; idx: number; tag: string; created_at: number }[];

    // check if the migration has been run
    const hasBeenRun = (idx: number, tag: string) =>
      dbMigrations.find((dbMigration) => {
        return dbMigration?.idx === idx && dbMigration?.tag === tag;
      });
    // if the migration has not been run, run it
    if (hasBeenRun(entry.idx, entry.tag) === undefined) {
      const migration = await readTextFile(await resolveResource(`${migrationFolder}/${entry.tag}.sql`));
      sqlite.execute(migration, []);
      sqlite.execute(
        /*sql*/ `INSERT INTO "__drizzle_migrations" (idx, tag, created_at) VALUES ($1, $2, $3)`,
        [entry.idx, entry.tag, Date.now()]
      );
    }
  }

  console.info("Migrations complete");
  return sqlite;
}